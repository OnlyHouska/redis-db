<?php

namespace App\Http;

use App\Constants\KeyType;
use App\Constants\SubkeyType;
use Illuminate\Support\Facades\Redis;

/**
 * Redis connection wrapper with JSON and Streams support
 * 
 * Provides helper methods for working with Redis JSON module and Redis Streams.
 * All data is stored as JSON documents using RedisJSON commands.
 */
final class RedisConnection
{
    /**
     * Get the underlying Redis client instance
     * 
     * @return \Redis Native Redis client
     */
    private static function getClient(): \Redis
    {
        return Redis::connection()->client();
    }

    /**
     * Get a JSON document from Redis
     * 
     * Uses JSON.GET to retrieve entire document
     * 
     * @param string $key Redis key
     * @return array Decoded JSON data or empty array if key doesn't exist
     */
    public static function getKey(string $key): array
    {
        $result = self::getClient()->rawcommand('JSON.GET', $key);
        return $result ? (json_decode($result, true) ?? []) : [];
    }

    /**
     * Store a JSON document in Redis
     * 
     * Uses JSON.SET to store data and optionally sets TTL
     * 
     * @param string $key Redis key
     * @param array $data Data to store as JSON
     * @param int|null $ttl Optional TTL in seconds (-1 for no expiry)
     * @return bool True if successful
     */
    public static function setKey(string $key, array $data, ?int $ttl = null): bool
    {
        // Store JSON document at root path ($)
        $result = self::getClient()->rawcommand('JSON.SET', $key, '$', json_encode($data));

        // Set expiration if TTL provided
        if ($result && $ttl !== null && $ttl >= -1) {
            self::getClient()->expire($key, $ttl);
        }

        return (bool) $result;
    }

    /**
     * Delete a key from Redis
     * 
     * @param string $key Redis key to delete
     * @return bool True if key was deleted, false if it didn't exist
     */
    public static function delKey(string $key): bool
    {
        if (!self::keyExists($key)) {
            return false;
        }

        return (bool) self::getClient()->del($key);
    }

    /**
     * Check if a key exists in Redis
     * 
     * @param string $key Redis key to check
     * @return bool True if key exists
     */
    public static function keyExists(string $key): bool
    {
        return (bool) self::getClient()->exists($key);
    }

    /**
     * Increment and return a counter for generating unique IDs
     * 
     * Uses Redis INCR command to atomically increment counter.
     * Counter key pattern: "type:counter"
     * 
     * @param KeyType $type Entity type (e.g., Task, User)
     * @return int New counter value (unique ID)
     */
    public static function incrementCounter(KeyType $type): int
    {
        return (int) self::getClient()->incr("$type->value:" . SubkeyType::Counter->value);
    }

    /**
     * Get all keys matching a pattern
     * 
     * Retrieves keys by pattern and filters out counter keys.
     * Pattern: "type:*" or "type:ID" if ID provided
     * 
     * @param KeyType $type Entity type
     * @param int|null $id Optional specific ID to match
     * @return array List of matching Redis keys (excluding counters)
     */
    public static function getKeys(KeyType $type, ?int $id = null): array
    {
        // Build pattern: either specific ID or wildcard
        $subpattern = $id ?? '*';

        // Get all keys matching pattern
        $keys = self::getClient()->keys("$type->value:$subpattern") ?: [];
        
        // Filter out counter keys from results
        return array_filter($keys, fn($k) => $k !== "$type->value:" . SubkeyType::Counter->value);
    }

    /**
     * Add an entry to a Redis Stream
     * 
     * Redis Streams are used for event logging and audit trails.
     * Stream name pattern: "stream:type-events"
     * 
     * @param KeyType $type Entity type
     * @param array $data Event data (key-value pairs)
     * @return string Entry ID generated by Redis (e.g., "1234567890123-0")
     */
    public static function addToStream(KeyType $type, array $data): string
    {
        // Convert associative array to flat array for XADD command
        $args = [];
        foreach ($data as $field => $value) {
            $args[] = (string) $field;
            // Convert scalar values to strings, encode arrays/objects as JSON
            $args[] = is_scalar($value) || $value === null ? (string) ($value ?? '') : json_encode($value);
        }

        // Add entry to stream with auto-generated ID (*)
        return (string) self::getClient()->rawcommand('XADD', "stream:$type->value-events", '*', ...$args);
    }

    /**
     * Read entries from a Redis Stream
     * 
     * Uses XRANGE to query stream entries within a range.
     * Useful for reading event history and audit logs.
     * 
     * @param KeyType $type Entity type
     * @param string $start Start ID ('-' for beginning)
     * @param string $end End ID ('+' for end)
     * @param int $count Maximum number of entries to return
     * @return array Array of stream entries [id, [field => value, ...]]
     */
    public static function rangeStream(KeyType $type, string $start = '-', string $end = '+', int $count = 100): array
    {
        $result = self::getClient()->rawcommand('XRANGE', "stream:$type->value-events", $start, $end, 'COUNT', $count);
        return is_array($result) ? $result : [];
    }
}
